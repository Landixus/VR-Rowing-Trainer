/*  Author: Grant Burgess
    Date: 03/05/17
    Purpose: To read a signal from the ANT+ device, and convert to the speed our enviroment will move at.
                most of this code has been pirated from the VRC project, it needs to be rewritten to suit
                our requirements. But this should suffice for testing purposes.
*/

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using ANT_Managed_Library;
using Dynastream.Fit;

public class Rowing_Speed : MonoBehaviour {
    public static double speed; // Speed generated by ERG
    public static double targetSpeed; // Last speed recorded
    private static double speedChange; // Speed required to get to targetSpeed
    private const double speedChangePeriod = 1.3; // Time to get to targetSpeed
    private static bool prevSet = false;
    private static double prevTime = 0;
    private static int prevRev = 0;
    private static float timeSinceLastUpdate;
    public static AntChannel channel; // ANT Channel being used
    public static double distance; //total distance travelled
    public static double distanceDelta; //distance travelled since last update

    [Range(1.0f, 4.0f)]
    public static double circumference = 2.0f;

    // Initialization
    void Start () {
		
        refreshAntChannel();
        speed = 0;
        targetSpeed = 0;
        speedChange = 0;
        timeSinceLastUpdate = Time.time;
        distance = 0;
    }
	
	// Update is called once per frame
	void Update () {
		
        double change = speedChange * Time.deltaTime;

        if (((speedChange > 0) && (speed < targetSpeed)) ||
            ((speedChange < 0) && (speed > targetSpeed)))
        {
            speed += change;
        }
        else
        {
            speed = targetSpeed;
        }
        if (Time.time - timeSinceLastUpdate > 2.0f)
        {
            targetSpeed = 0;
            speedChange = (targetSpeed - speed) * speedChangePeriod;
        }
        //Debug.Log("Speed:" + speed);
        distance = distance + getDistance();
		return;
    }
	
    public static void refreshAntChannel() {
        AntManager.Instance.Init();
        // I'm using the combined channel because that is what the VRC code was using
        channel = AntManager.Instance.OpenChannel(ANT_ReferenceLibrary.ChannelType.BASE_Slave_Receive_0x00, 0, 0, 121, 0, 57, 8086, false); //Combined
        //channel = AntManager.Instance.OpenChannel(ANT_ReferenceLibrary.ChannelType.BASE_Slave_Receive_0x00, 0, 0, 122, 0, 57, 8102, false); //Cadence
        //channel = AntManager.Instance.OpenChannel(ANT_ReferenceLibrary.ChannelType.BASE_Slave_Receive_0x00, 0, 0, 123, 0, 57, 8118, false); //Speed
        channel.hideRXFAIL = true;
        channel.onChannelResponse += Channel_onChannelResponse; ;
        channel.onReceiveData += Channel_onReceiveData;
        return;
    }
	
    private static void Channel_onChannelResponse(ANT_Response response)
    {
        return;
    }
	
	private static void Channel_onReceiveData(Byte[] data)
    {
        //data description
        //0-1 Cadence Event Time
        //2-3 Cadence Revolution count
        //4-5 Bike Speed Event Time
        //6-7 Bike Speed Revolution count

        int dataPageNum = data[0] >> 1;
        //Debug.Log("Raw Data: " + dataPageNum);
        bool pageChange = Convert.ToBoolean((data[0] << 7) >> 7);
        int timeLSB = data[4];
        int timeMSB = data[5];
        int revLSB = data[6];
        int revMSB = data[7];

        double time = ((timeMSB << 8) | timeLSB) / 1024.0f;
        int revolution = (revMSB << 8) | revLSB;

        //Debug.Log("time: " + time);
        //Debug.Log("revolution: " + revolution);

        if (revolution != prevRev)
        {
            if (!prevSet)
            {
                prevSet = true;
                targetSpeed = 0;
            }
            else
            {
                double timeDelta;
                if (time < prevTime)
                {
                    timeDelta = time - (prevTime - 64.0f);
                }
                else
                {
                    timeDelta = time - prevTime;
                }
                if (revolution - prevRev == 0)
                {
                    targetSpeed = circumference / timeDelta;
                }
                else
                {
                    targetSpeed = circumference * (revolution - prevRev) / timeDelta;
                }

                speedChange = (targetSpeed - speed) * speedChangePeriod;
                timeSinceLastUpdate = Time.time;
            }
        }
        prevRev = revolution;
        prevTime = time;
        return;
    }

    public double getDistance()
    {
        distanceDelta = speed * timeSinceLastUpdate;
        //move player boat 
        return distanceDelta;
    }
	
}
